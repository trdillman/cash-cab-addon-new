"""Post-pipeline clean-up helpers for BLOSM.

Usage:
- Called automatically by BLOSM_OT_FetchRouteMap once the asset pipeline completes.
- Can also be invoked manually via route.pipeline_finalizer.run(context.scene) for quick driver refresh/cleanup.
- Keep miscellaneous manual helpers in route/maintenance_utils.py instead of editing core pipeline files.
- Tyler's Sandbox (see below) runs last; drop personal tweaks there so they survive updates.
  Example tweak: inside _run_tylers_sandbox, grab the "Route" curve and set `route_curve.data.bevel_depth = 0.6`.
"""

from __future__ import annotations

from contextlib import contextmanager
from typing import Optional, Union
from pathlib import Path

import bpy
import os

from . import anim as route_anim
from . import assets as route_assets
from . import nodes as route_nodes
from .config import DEFAULT_CONFIG
from .water_manager import ISLAND_PLANE_Z
from ..app import blender as blenderApp

CN_TOWER_LAT = 43.6425662
CN_TOWER_LON = -79.3870568
CN_TOWER_OBJECT_NAME = "CN_TOWER"
CN_TOWER_ASSET_BLEND = route_assets.ASSET_DIRECTORY / "ASSET_CNTower.blend"
CAR_TRAIL_NODE_GROUP_NAME = "ASSET_CAR_TRAIL"
CAR_TRAIL_BEVEL_DRIVERS = (
    ("bevel_factor_end", "offset_factor - 0.0055"),
    ("bevel_factor_start", "offset_factor - 0.075"),
)
ROUTE_SUBSURF_NAME = "RouteSubsurf"
ROUTE_SMOOTH_NAME = "RouteSmooth"
ROUTE_SUBSURF_NAME = "RouteSubsurf"

# --- AUTO PATCH HELPERS (non-breaking) ---
def _pick_first_object_in_collection(coll):
    if not coll:
        return None
    # prefer EMPTY containing 'BASE'
    for o in coll.objects:
        try:
            if o.type == 'EMPTY' and 'BASE' in o.name.upper():
                return o
        except Exception:
            pass
    for o in coll.objects:
        try:
            if o.type == 'EMPTY':
                return o
        except Exception:
            pass
    return next(iter(coll.objects), None)
# --- END AUTO PATCH HELPERS ---


def _ensure_cn_tower_marker(scene: Optional[bpy.types.Scene]) -> None:
    """Ensure a CN_TOWER mesh object is present and positioned at the real location.

    Prefers the ASSET_CNTower.blend asset (CN_TOWER mesh). If unavailable, falls
    back to the legacy EMPTY marker.
    """
    if scene is None:
        return
    print("[BLOSM] _ensure_cn_tower_marker invoked")

    marker = bpy.data.objects.get(CN_TOWER_OBJECT_NAME)

    # If no CN_TOWER object exists yet, try to append it from ASSET_CNTower.blend
    if marker is None and CN_TOWER_ASSET_BLEND.exists():
        try:
            with bpy.data.libraries.load(str(CN_TOWER_ASSET_BLEND), link=False) as (data_from, data_to):
                # Prefer an object explicitly named CN_TOWER
                if CN_TOWER_OBJECT_NAME in data_from.objects:
                    data_to.objects = [CN_TOWER_OBJECT_NAME]
                elif data_from.objects:
                    # Fallback: bring in all objects; pick by name later
                    data_to.objects = list(data_from.objects)
        except Exception as exc:
            print(f"[BLOSM] WARN CN Tower asset append failed: {exc}")

        # Re-resolve marker after append
        marker = bpy.data.objects.get(CN_TOWER_OBJECT_NAME)

    # Final fallback: legacy EMPTY marker if mesh asset is not available
    if marker is None:
        marker = bpy.data.objects.new(CN_TOWER_OBJECT_NAME, None)
        marker.empty_display_type = 'SPHERE'
        marker.empty_display_size = 10.0

    # Ensure the marker is linked to the scene
    marker_collections = list(getattr(marker, "users_collection", []) or [])
    if scene.collection not in marker_collections:
        try:
            scene.collection.objects.link(marker)
        except RuntimeError:
            pass

    # Optionally keep the tower grouped in its own collection
    def _ensure_tower_collection(scene, marker_obj):
        coll = bpy.data.collections.get("ASSET_CNTower")
        if coll is None:
            coll = bpy.data.collections.new("ASSET_CNTower")
        existing_collection_names = {child.name for child in scene.collection.children}
        if coll.name not in existing_collection_names:
            try:
                scene.collection.children.link(coll)
            except RuntimeError:
                pass
        if marker_obj and marker_obj.name not in {obj.name for obj in coll.objects}:
            try:
                coll.objects.link(marker_obj)
            except RuntimeError:
                pass
        return coll

    tower_coll = _ensure_tower_collection(scene, marker)
    print(f"[BLOSM] CN_TOWER linked into ASSET_CNTower (collections={[c.name for c in getattr(marker, 'users_collection', []) or []]})")

    projection = getattr(blenderApp.app, "projection", None)
    if projection is None:
        origin = None
        try:
            origin = tuple(scene.get("cashcab_projection_origin", ())) if scene else None
        except Exception:
            origin = None
        addon = getattr(scene, "blosm", None)
        try:
            if origin and len(origin) == 2:
                blenderApp.app.setProjection(origin[0], origin[1])
            elif addon:
                center_lat = (getattr(addon, "minLat", CN_TOWER_LAT) + getattr(addon, "maxLat", CN_TOWER_LAT)) / 2
                center_lon = (getattr(addon, "minLon", CN_TOWER_LON) + getattr(addon, "maxLon", CN_TOWER_LON)) / 2
                blenderApp.app.setProjection(center_lat, center_lon)
            projection = getattr(blenderApp.app, "projection", None)
        except Exception as exc:
            print(f"[BLOSM] WARN CN Tower projection setup failed: {exc}")
    if projection is None:
        return
    try:
        x, y, _ = projection.fromGeographic(CN_TOWER_LAT, CN_TOWER_LON)
        marker.location = (x, y, 0.0)
    except Exception as exc:
        print(f"[BLOSM] WARN CN Tower marker placement failed: {exc}")
        return
    print(f"[BLOSM] CN Tower marker placed at ({marker.location.x:.3f}, {marker.location.y:.3f})")


def _ensure_car_trail_node_group() -> bpy.types.NodeTree | None:
    ng = bpy.data.node_groups.get(CAR_TRAIL_NODE_GROUP_NAME)
    if ng:
        return ng

    path = route_assets.CAR_BLEND_PATH
    candidate = None
    try:
        with bpy.data.libraries.load(str(path), link=False) as (data_from, data_to):
            candidates = [name for name in (getattr(data_from, 'node_groups', None) or []) if 'Geometry Nodes' in name]
            if candidates:
                candidate = candidates[0]
                data_to.node_groups = [candidate]
    except Exception as exc:
        print(f"[BLOSM] WARN car trail node group append failed: {exc}")
        return None

    if candidate and candidate in bpy.data.node_groups:
        base = bpy.data.node_groups.get(candidate)
        try:
            copy = base.copy()
            copy.name = CAR_TRAIL_NODE_GROUP_NAME
            return copy
        except Exception as exc:
            print(f"[BLOSM] WARN car trail node group copy failed: {exc}")
            return base
    return None


def _configure_car_trail_drivers(curve_data: bpy.types.Curve, car_obj: Optional[bpy.types.Object]) -> bool:
    if curve_data is None or car_obj is None:
        return False

    follow = next((c for c in car_obj.constraints if c.type == 'FOLLOW_PATH'), None)
    if follow is None:
        print("[BLOSM] WARN car trail driver target constraint missing")
        return False

    anim = curve_data.animation_data_create()
    drivers = getattr(anim, "drivers", None) or []
    for prop, _ in CAR_TRAIL_BEVEL_DRIVERS:
        for existing in list(drivers):
            if existing.data_path == prop:
                anim.drivers.remove(existing)

    created = False
    for prop, expression in CAR_TRAIL_BEVEL_DRIVERS:
        try:
            fcurve = curve_data.driver_add(prop)
            driver = fcurve.driver
            driver.type = 'SCRIPTED'
            driver.expression = expression

            var = driver.variables.new()
            var.name = 'offset_factor'
            target = var.targets[0]
            target.id = car_obj
            target.data_path = f'constraints["{follow.name}"].offset_factor'
            created = True
        except Exception as exc:
            print(f"[BLOSM] WARN car trail driver setup failed for {prop}: {exc}")

    return created


def _build_car_trail_from_route(scene: Optional[bpy.types.Scene]) -> bpy.types.Object | None:
    if scene is None:
        return None

    route_obj = bpy.data.objects.get('ROUTE') or bpy.data.objects.get('Route')
    if route_obj is None:
        return None

    car_collection = bpy.data.collections.get('ASSET_CAR')
    if car_collection is None:
        return None

    existing = bpy.data.objects.get('CAR_TRAIL')
    if existing:
        for coll in list(getattr(existing, 'users_collection', []) or []):
            coll.objects.unlink(existing)
        bpy.data.objects.remove(existing, do_unlink=True)

    car_trail_data = route_obj.data.copy()
    car_trail_data.name = 'CAR_TRAIL_DATA'
    car_trail_data.resolution_u = 12
    car_trail_data.bevel_depth = 0.0
    car_trail_data.bevel_resolution = 4
    car_trail_data.extrude = 0.0
    car_trail_data.bevel_factor_mapping_start = 'SPLINE'
    car_trail_data.bevel_factor_mapping_end = 'SPLINE'
    car_trail_data.offset = 0.77
    car_trail_data.taper_radius_mode = 'ADD'
    car_trail_data.use_radius = True

    # Match legacy trail look: use profile curve and gradient material
    profile_curve = bpy.data.objects.get('_profile_curve')
    if profile_curve:
        try:
            car_trail_data.bevel_object = profile_curve
            car_trail_data.bevel_mode = 'OBJECT'
        except Exception as exc:
            print(f"[BLOSM] WARN setting CAR_TRAIL bevel object failed: {exc}")

    # Ensure CAR_TRAIL has a visible material similar to asset CAR_TRAIL
    try:
        mat = (
            bpy.data.materials.get("Basic Gradient.002")
            or bpy.data.materials.get("Basic Gradient.001")
            or None
        )
        if mat is not None:
            car_trail_data.materials.clear()
            car_trail_data.materials.append(mat)
    except Exception as exc:
        print(f"[BLOSM] WARN setting CAR_TRAIL material failed: {exc}")
    car_trail = bpy.data.objects.new('CAR_TRAIL', car_trail_data)
    car_trail.location = route_obj.location
    car_trail.rotation_euler = route_obj.rotation_euler
    car_trail.scale = route_obj.scale

    try:
        car_collection.objects.link(car_trail)
    except RuntimeError:
        pass

    car_obj = _resolve_car(scene)
    if car_obj is None:
        print("[BLOSM] WARN car object not resolved for trail drivers")

    for mod in list(car_trail.modifiers):
        car_trail.modifiers.remove(mod)

    node_group = _ensure_car_trail_node_group()
    if node_group:
        mod = car_trail.modifiers.new(name='CarTrailGeo', type='NODES')
        mod.node_group = node_group
    else:
        print("[BLOSM] WARN car trail node group unavailable")

    _configure_car_trail_drivers(car_trail.data, car_obj)
    return car_trail

# ... (rest of file truncated for brevity - this is just the backup)